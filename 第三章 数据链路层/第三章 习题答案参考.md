***本答案仅供参考，如有不妥之处，欢迎提pr***

1. 以太网使用一个前导码再结合一个字节计数来分割帧。如果用户试图发送的数据包含了该前导码，则会发生什么情况？<br>
**分析**：前导码：交替的0和1，设备从静默状态变成有信号状态，标志以太网帧的开始。<br>
字节计数法：在帧头部使用一个计数字段来标明帧内字节数，当目的节点接收到字节计数值时就知道后面跟随的字节数，从而可以确定帧结束的位置（计数字段提供的字节数包含自身所占用的一个字节），这种方法最大的问题，如果计数字段出现了错误，即失去了帧边界划分的依据，接收方就无法判断所传输帧的结束位和下一帧的开始位，收发双方将失去同步。<br>
**解答**：若用户试图发送的数据包含该前导码，但是计数字段没有发生错误，则通过字节计数可以确定帧边界，该前导码被当作数据传输；若计数字段发生了错误，刚好字段长度是到包含该前导码的数据前面，则该前导码会被认作下一帧的开始，且目前帧的错误会被忽略，被当作一个正确帧提交给网络层，且后续的帧找不到正确边界。

2. 在一个数据流的中间出现了这样的数据：A  B  ESC  C  ESC  FLAG  FLAG  D，假设该数据流采用了本章介绍的字节填充算法，经过填充之后的输出是什么？<br>
**解答**：A B ESC ESC C ESC ESC ESC FLAG ESC FLAG D

3. 字节填充算法的最大开销是多少？<br>
**解答**：最大开销是100%，此时数据帧中全为ESC或FLAG，经过填充之后，原数据字符数和转义字符数相同，最大开销=转义字符数/数据字符数=100%。

4. 你收到了下面的数据段：0110 0111 1100 1111 0111 1101，并且你知道该协议使用了比特填充编码。请给出经过解码之后的数据。<br>
**解答**：连续五个1后添加一个0。解码后的数据为：0110 0111 1101 1110 1111 11。

5. 当采用比特填充技术时，单个比特的丢失、插入或者修改有可能不被校验和检测到吗？如果不能检测到，为什么？如果能检测到，如何检测？校验和长度在这里起作用了吗？<br>
**解答**：有可能。例如帧的数据部分出现了01111110（如果不在数据部分，该比特模式标记着帧的开始和结束），当帧经发送方发出时，被填充后的比特流为011111010，但是如果第二个0丢失，则变为01111110，被接收方识别为帧的结束。然后接收方在该帧尾前面寻找检验和，并对它进行验证。如果检验和是16位，那么被错误地看成是检验和的16位内容碰巧经验证后仍然正确的概率是 $\frac{1}{2^{16}}$。如果刚好是 $\frac{1}{2^{16}}$的概率的这件事情发生了，则校验和检验不到，否则，能检验到。校验和长度在这里起作用了：校验和越长，传输错误不被发现的概率越低（虽然概率永远不会为0）。

6. 一个上层数据包被分为10帧，每一帧有80%的机会无损地达到目的地。如果数据链路协议没有提供错误控制，则该报文平均需要发送多少次才能完整地到达接收方？<br>
**解答**：<br>
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_6.png)

7. 在什么样的环境下，一个开环协议（比如海明码）有可能比本章讨论的反馈类协议更加合适？<br>
**分析**：开环协议：无反馈信息的协议；反馈协议：依赖重传的协议。<br>
**解答**：传播延迟长的信道，如探测火星或金星的情况，需要采用前向纠错方法；或者在某些军事环境中，接收方不想暴露自己的位置，所以不发送任何信息，只接受信息。如果错误率足够低，纠错码的冗余位串不是很长，还能纠正所有错误，这时选择开环协议也是比较合适的。

8. 为了提供比单个奇偶位更强的可靠性，一种检错编码方案如下：用一个奇偶位检查所有奇数序号的位，用另一个奇偶位检查所有偶数序号的位。这种编码方案的海明距离是多少？<br>
**分析**：0101 1010 奇数位0 0 1 1，奇数个数为0，不妨在尾部添加一个1， 偶数位 1 1 0 0同理在尾部添加一个1，0101101011。所以我们能够看出，这种方式之所以更可靠的原因是，如果发生一位错误，同单个奇偶位检验，能够检查出错误；另一方面，假设发生了两位错误，其中一个发生在奇数位，一个发生在偶数位，很显然，也能够通过检验码检测出错误。不过，如果两位都发生在奇数位，还是无法检验出来。<br>
**解答**：对于偶数位或者奇数位的数据改变一位，不会产生另一个有效码字；改变两位，将会产生另一个码字，所以海明距离是2。

9. 你可能注意到，日常使用的即时消息服务并没有提供错误检测功能，你决定自己采用一个简单的错误检测机制：所有的消息都发送两次。此时对应的海明距离和编码率是多少？与增加一个奇偶校验位的方案相比怎么样？<br>

**分析**：每条消息发送两次，也就意味着一次发送的是消息本身，另一次发送是作为错误检测的功能存在<br>
**解答**：假设一条消息m个数据位，校验位是r，则由题m=r；当消息出现一位错误时，第二次的消息作为错误检测的校验位，它可能出现同样位置的错误，所以一位错误就有可能使一个消息转变成另一个消息，所以海明距离是1；编码率是m/(m+r) = 1/2。<br>
增加一个奇偶校验位，能检测奇数位错误，且编码率是m/(m+1)，远小于1/2，信道负载大大减小。<br>

10. 考虑一个错误检测方案：每条消息发送两次。假设恰好有两个比特错误发生了，那么该错误未被检测到的概率有多少？当使用一个奇偶校验位时，错误未被检测到的概率是多少？哪种方法能检测到更多的错误？<br>
**解答**：假设一条消息m个数据位，则两个比特位发生错误的所有可能情况为：m(m-1)，第二次发送这个消息，同样位置发生错误的概率为1/[m(m-1)]，即为两位错误未被检测到的概率。<br>
当使用一个奇偶校验位时，假设使用一个偶校验位：即数据中1的位数为偶数时，校验位为0，为奇数时，校验位为1；当发生偶数次错误时，偶校验检测不出错误，此时错误未检测到的概率为：1/(m(m-1))+1/(m(m-1)(m-2)(m-3))+⋯。<br>
对于一条消息发送两次的检测方案，奇数个比特错误发生，它也可能检测不出来，比如3个比特错误发生检测不出的概率为：1/(m(m-1)(m-2))，而奇偶校验可以检测出来。所以奇偶校验能检测出更多的错误。

11. 一个8位字节的二进制值为10101111，采用一个偶校验位海明码进行编码。经过编码以后的二进制值是什么？<br>
**解答：**
[此链接](https://blog.csdn.net/youandme520/article/details/107002824/)中有很详细的海明码校验码位置计算与校验位值的计算。<br>
参考P165页，对于8位的数据，进行编码后，其校验位的位置在1，2，4，8，其值记为X1，X2，X3，X4；数据位的位置为3，5，6，7，9，10，11，12，其值记为P3，P5，P6，P7，P9，P10，P11，P12<br>
3：0011<br>
5：0101<br>
6：0110<br>
7：0111<br>
9：1001<br>
10：1010<br>
11：1011<br>
12：1100<br>
P3，P5，P6，P7，P9，P10，P11，P12：10101111<br>
<br>
根据链接中的方法：<br>
X1⊕P3⊕P5⊕P7⊕P9⊕P11=0，即X1⊕1⊕0⊕0⊕1⊕1=0，推出X1=1；<br>
X2⊕P3⊕P6⊕P7⊕P10⊕P11=0，即X2⊕1⊕1⊕0⊕1⊕1=0，推出X2=0；<br>
X4⊕P5⊕P6⊕P7⊕P12=0，即X2⊕0⊕1⊕0⊕1=0，推出X4=0；<br>
X8⊕P9⊕P10⊕P11⊕P12=0，即X2⊕1⊕1⊕1⊕1=0，推出X4=0；<br>
<br>
所以最后的编码结果为：101001001111

12. 一个8位字节的二进制值位10011010，采用一个奇校验位海明码进行编码。经过编码以后二进制值是什么？<br>
**解答：**<br>
对于8位的数据，进行编码后，其校验位的位置在1，2，4，8，其值记为X1，X2，X3，X4；数据位的位置为3，5，6，7，9，10，11，12，其值记为P3，P5，P6，P7，P9，P10，P11，P12<br>
3：0011<br>
5：0101<br>
6：0110<br>
7：0111<br>
9：1001<br>
10：1010<br>
11：1011<br>
12：1100<br>
P3，P5，P6，P7，P9，P10，P11，P12：10011010<br>

![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_12.png)<br>
根据链接中的方法：<br>
X1⊕P3⊕P5⊕P7⊕P9⊕P11=1，即X1⊕1⊕0⊕1⊕1⊕1=1，推出X1=1；<br>
X2⊕P3⊕P6⊕P7⊕P10⊕P11=1，即X2⊕1⊕0⊕1⊕0⊕1=1，推出X2=0；<br>
X4⊕P5⊕P6⊕P7⊕P12=1，即X4⊕0⊕0⊕1⊕0=1，推出X4=0；<br>
X8⊕P9⊕P10⊕P11⊕P12=1，即X8⊕1⊕0⊕1⊕0=1，推出X8=1；<br>
<br>
所以最后的编码结果为：101000111010

13. 接收方收到一个12位的奇校验和海明码，其16进制值为0xB4D。该码的原始值是多少（按16进制）？假设至多发生了一位错误。<br>
**解答：**<br>
1011 0100 1101，由m+r+1<=2^r（P165 3-1公式），m为数据位，r为校验位，故m+r=12，所以13<=2^r，所以r=4。即12位的奇校验和海明码有8位数据位和4位校验位。<br>
因此校验位X1，X2，X4，X8分别为1，0，1，0<br>
将校验位按照奇校验和海明码的校验模式（前面例题的那种方法）进行校验。<br>
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_13.png)<br>
X1⊕P3⊕P5⊕P7⊕P9⊕P11 = 1⊕1⊕0⊕0⊕1⊕0 = 1，校验正确。<br>
X2⊕P3⊕P6⊕P7⊕P10⊕P11= 0⊕1⊕1⊕0⊕1⊕0 = 1，校验正确。<br>
X4⊕P5⊕P6⊕P7⊕P12 = 1⊕0⊕1⊕0⊕1 = 1，校验正确。<br>
X8⊕P9⊕P10⊕P11⊕P12 = 0⊕1⊕1⊕0⊕1=1，校验正确。<br>

14. 海明码的距离为3，可以用来纠正单个错误或者检测两个错误。这两个功能可以同时实现吗？请解释为什么可以或者为什么不可以。一般而言，如果海明距离为n，可以纠正多少错误？可以检测多少错误？<br>
**解答**：不可以同时实现（参考《计算机网络》的165-166页）：如果所有奇偶校验位都正确，则没有错误。否则，错误奇偶校验位的位置总和将识别错误位。例如，如果位置1、2和8的奇偶校验位指示错误，则位1 + 2 + 8 = 11是错误的。如果只有一个奇偶校验位指示错误，则奇偶校验位本身就是错误的。如果是某个代码字的双比特错误或不同代码字的单个比特错误，海明码的计算方式并不能定位出来错误在哪里，但是能检测出来错误，所以，海明码只能纠正单个错误或检测两个错误。<br>
一般而言，如果海明距离为n，可以检测出n-1个错误，可以纠正(n-1)/2个错误（参考书164页）。<br>

15. 考虑一个协议：每16个字节的消息数据增加1字节的冗余数据。该协议可以使用海明码纠正单个错误吗？<br>
**解答**：<br>
由m+r+1<=2^r（P165 3-1公式），m为数据位，r为校验位。16字节=128位，1字节=8位。<br>
m=8*16=128，128+r <=2^r，解出r=8位（即1字节），故该协议可以使用海明码纠正单个错误。<br>

16. 检测错误的一种方法是按 $n$行、每行 $k$位来传输数据，并且在每行和每列加上奇偶位。其中右下角是一个校验其所在行和列的奇偶位。这种方案能检测出所有的1位错误吗？两位错误呢？3位错误呢？请说明这种方案无法检测出某些4位错误。<br>
**解答**：单个错误会让水平和垂直奇偶校验结果都显示错误；两个错误不管它们在同一行/列，两行/列也容易被检测出来；三个错误不管它们在同一行/列，两行/列或者三个不同行/列都会被检测出。
可以用一个 $n$行 $k$列的矩阵来描述错误，在该矩阵中，正确的位用0表示，错误的位用1表示，当四位错误处于同一个矩形顶点时，检测不出来。<br>

17. 在第16题中，多少错误可以被检测和纠正？<br>
**解答**：用 $n4行 $k$列矩阵来描述错误，在该矩阵中，正确的位用0表示，错误的位用1表示。因为有4位错误，所以每个错误矩阵中都有4个1：第一个1有nk种位置可能，第二个1有 $nk-1$种可能，第三个1有 $nk-2$种放置可能，第四个1有 $nk-3$种可能，错误矩阵总数为： $nk(nk-1)(nk-2)(nk-3)$。当4位错误即4个1处于同一个矩形顶点时检测不出错误，使用笛卡尔坐标，每一位都用在第一象限中的坐标 $(x, y)$表示，这里 $0<=x<=k,0<=y<=n$，那么每一位的 $x$坐标的可能值是 $0，1，2，…, k-2, k-1$； $y$坐标的可能值是 $0, 1, 2, …, n-2, n-1$。假定4个1处于的同一个矩形的最靠近原点（即矩形的左下方顶点）的位坐标是 $(p, q)$，那么对应于顶点 $(p, q)$的合法矩形的个数是 $(k-p-1)(n-q-1)$。因此对于所有可能的 $p$和 $q$，可以得到的矩形总数是：<br>
 $$\sum_{p=0}^{k-2}\sum_{q=0}^{n-2}(k-p-1)(n-q-1)$$ <br>
这即是检测不出的错误的所有可能，所以能检测出的错误数目为：
$$nk(nk-1)(nk-2)(nk-3)-\sum_{p=0}^{k-2}\sum_{q=0}^{n-2}(k-p-1)(n-q-1)$$

18. 为了纠正所有的单个错误和两个错误，需要在m位消息上增加r个冗余位，请给出r的下界公式。<br>
**解答**：为了纠正2个错误，需要一个海明距离为 $2\times2 + 1 = 5$ 的编码。对于 $2^m$条合法消息，每条消息都对应 $n(n-1)$个距离为2的非法码字。这些非法码字的构成方式为：将该消息对应的合法码字的 $n$位中的两位取反，可以得到 $n(n-1)$个距离为2的非法码字。因此，每 $2^m$条合法消息需要 $n(n-1)+3$个位模式标识它们。由于总共有 $2^n$个位模式，所以，必须有 $[n(n-1)+3]\times 2^m <=  2^n$，而 $n=m+r$，所以：<br>
[(m+r)(m+r-1)+3] <= 2^ r

19. 在18题的基础上，请解释为什么复杂的基于概率的纠错机制，比如本章中讨论的卷积码和低密度奇偶检验码能流行起来？<br>
**解答**：因为这些纠错机制虽然复杂，但是不会占用太多信道资源，从18题可以发现，一个能纠正出两位错误的冗余位已经相当长了，所以，更别说纠正更多位错误。

20. 假设数据以块形式传输，每块为1000比特。在什么样的最大错误率下，错误检测和重传机制（每块一个校验位）比使用海明码更好？假设比特错误相互独立，并且在重传过程中不会发生比特错误。<br>
**解答**： $m+r+1<=2^r$（P165 3-1公式）， $m$为数据位， $r$为校验位，当 $m=1000$时， $r=10$，所以1000比特数据使用海明码至少需要10个校验位，总的传输位数是1010比特；如果是检错的话，只需要1位检验码。假设出错率是 $x/bit$，那么一个块出错的次数为 $1000x$。每次出错需要重传1001bit，所以总传的位数是 $1001+1000x\times1001$(其中加的1001是检验码出错)。要使检错机制更优秀，那么 $1001+1000x\times1001<1010$。所以出错率必须小于 $9\times10^{-6}$。

21. 一个具有n行k列的块使用水平和垂直奇偶校验位进行错误检测。假设正好有4位由于传输错误被反转。请推导出该错误无法被检测出来的概率表达式。<br>
**分析**: 奇偶校验：偶校验的计算是统计位流中1的个数，如果1的个数是奇数，就把奇偶位设置成1，使得在数据和奇偶位中1的总个数是一个偶数。奇校验跟偶校验相反，在数据和奇偶位中1的总个数应该是一个奇数。<br>
水平和垂直奇偶校验：在每行每列都增加奇偶位。<br>
**解答**：考虑用 $n$行 $k$列的矩阵来描述错误图案，在该矩阵中，正确的位用0表示，不正确的位用1表示。4位传输错误则意味着每个可能的错误矩阵中都有4个1。那么错误矩阵有多少个呢？有 $nk$种放置第一个1的方法， $(nk-1)$种放置第二个1的方法， $(nk-2)$和 $(nk-3)$种选择第三个和第四个1的方法；所以，错误矩阵的数目是 $nk(nk-1)(nk-2)(nk-3)$。<br>
仅当4个1处在同一个矩形的4个顶点时，才会检验不出传输错误。使用笛卡尔坐标，每一位都用在第一象限中的坐标 $(x, y)$表示，这里 $0 <= x < k$, $0 <= y < n$，那么每一位的 $x$坐标的可能值是 $0, 1, 2, …, k-2, k-1$； $y$坐标的可能值是 $0, 1, 2, …, n-2, n-1$。假定4个1处于的同一个矩形的最靠近原点（即矩形的左下方顶点）的位坐标是 $(p, q)$，那么对应于顶点 $(p, q)$的合法矩形的个数是 $(k-p-1)(n-q-1)$。因此对于所有可能的 $p$和 $q$，可以得到的矩形总数是：
 $$\sum_{p=0}^{k-2}\sum_{q=0}^{n-2}(k-p-1)(n-q-1)$$ <br>
所以未被检测出来的错误概率是：<br>
 $$\frac{\sum_{p=0}^{k-2}\sum_{q=0}^{n-2}(k-p-1)(n-q-1)}{nk(nk-1)(nk-2)(nk-3)}$$

22. 假设使用Internet校验和（4位字）发送一条消息：1001 1100 1010 0011。校验和的值是什么？<br>
**分析**：Internet校验和（4位字）：在发送方，先把被校验的数据划分为许多4位字的序列。如果数据的字节长度为奇数，则在数据尾部补一个字节的0以凑成偶数。用反码算数运算把所有4位字相加后，然后再对和取反码，便得到校验和。<br>
在接收方，将收到的数据报（包括校验和字段），将所有4位字再使用反码算数运算相加一次，将得到的和取反，即得出校验和的计算结果。如果数据报在传输过程中没有任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。<br>
反码算数运算：两个数进行二进制反码求和的运算规则是从低位到高位逐列进行计算。0和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加1。<br>
**解答**：（1）先4位一组分解：1001，1100，1010，0011；<br>
（2）从低到高进行反码算数运算：<br>
0011 + 1010 = 1101（1和1相加注意要产生一个进位1）<br>
1101 + 1100 = 1001 + 1 = 1010（最高位1和1相加，则在结果上再加1）<br>
1010 + 1001 = 0100<br>
（3）将反码算数运算得到的结果取反：0100取反后是1011。<br>
所以校验和的值是1011。

23. x^7+x^5+1被生成多项式x^3+1除，所得余数是什么？<br>
**解答**：即求101000010000被1001除：<br>
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_23.png)<br>
所以余数是111。

24. 使用本章介绍的标准CRC方法传输比特流10011101。生成多项式为x^3+1。实际传输的位串是什么？假设左边开始的第3比特在传输过程中反转了，请说明这个错误可以在接收方被检测出来。给出一个该比特流传输错误的实例，使得接收方无法检测出该错误。<br>
**解答**：取信息10011101，生成多项式1001，生成多项式阶数是3，所以在比特流后面补上3个0：10011101000。如下左图相除：<br>
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_24_1.png)
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_24_2.png)<br>
余数是100，10011101000 - 100 = 10011101100，即为实际传输位串。<br>
如上右图，是到达接收端的比特流，其中左边开始第3比特在传输过程中从0反转为1，接收端用10111101100除1001得到的结果，其中余数为100，不是0，所以接收方判定这个比特流在传输过程中出错。
当到达接收方的比特流能被生成多项式整除，则接收方检测不出比特流的错误，如当到达接收方的比特流为10011001000时，被1001除余数为0，此时接收方检测不出其错误。

25. 使用本章介绍的标准CRC方法传输比特流11100110。生成多项式为x^4+x^3+1。实际传输的位串是什么？假设左边开始的第3比特在传输过程中反转了，请说明这个错误可以在接收方被检测出来。给出一个该比特流传输错误的实例，使得接收方无法检测出该错误。<br>
**解答**：生成多项式为11001，阶数是4阶，所以在传输的比特流后面加4个0：111001100000，然后被生成多项式除，过程如下左图：<br>
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_25_1.png)
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_25_2.png)<br>
余数为0110，111001100000 – 0110 = 111001100110，即为实际传输的位串。<br>
如果左边第3比特在传输的过程中从1反转为0，则接收方接收到的比特流是：110001100110，这时接收方将这个出错的比特流被生成多项式除，过程如上右图，发现余数是0101，不为0，所以接收方能检测出这个错误。<br>
若要接收方无法检测出错误，两者相除余数为0即可，则110001100110 – 0101 = 110001100011这个比特流不会被接收方检测出。

26. 数据链路协议总是把CRC放在尾部而不是头部，这是为什么？<br>
**解答**：CRC是在发送期间进行计算的。一旦把最后一位数据送上外出线路，就立即把CRC编码附加在输出流的后面发出。如果把CRC编码放在帧的头部，那么就要在发送之前把整个帧先检查一遍来计算CRC，这样每个字节都要处理两遍，一遍计算检验码，一遍发送。CRC放在尾部就可以把处理时间减半。

27. 在3.3.3节讨论ARQ协议时，概述了一种场景，由于确认帧的丢失导致接收方接收了两个相同的帧。如果不会出现丢帧（消息或者确认），接收方是否还有可能收到同一帧的多个副本？<br>
**解答**：可能。如果出现CPU过载的情况，ACK的发送出现延迟，当ACK到达发送方时，定时器已经超时的情况。

28. 考虑一个具有4kb/s速率和20ms传输延迟的信道。帧的大小在什么范围内，停-等式协议才能获得至少50%的效率？<br>
**解答**：当发送1帧的时间等于信道传播延迟的2倍时，信道利用率是50%。或者说，当发送一帧的时间等于来回路程的传播延迟时，效率将是50%。<br>
信道传播延迟的2倍是：20ms * 2 = 40ms；<br>
现在的发送速率是4kb/s，即每秒4000bit，发送1bit需要0.25ms；<br>
40ms时间能发送的数据量是：40ms/(0.25ms/bit) = 160bit；<br>
所以，帧大于160bit，停-等协议才有至少50%的效率。

29. 两个协议A和B唯一的差异在于它们的发送窗口的大小。协议A使用一个20帧的发送窗口，协议B是一个停-等式协议。这两个协议运行在两个相同的信道上。如果协议A达到了几乎100%的带宽效率，那么协议B的带宽效率是多少？<br>
**解答**：协议A使用20帧的发送窗口，且达到几乎100%的带宽效率，所以说明A的最大窗口大小就是20帧，也意味着链路上最多有20个未被确认的帧。
而停-等式协议的窗口大小是1，所以协议B的带宽效率为1/20=0.05。

30. 在一个单向传输延迟为50ms的信道上使用900比特的帧，一个停-等式协议达到了25%的带宽效率。该信道的带宽是多少？<br>
**解答**：停-等式协议是每次只能发送一个帧，一个停等式协议的带宽效率 = 25%，所以一帧从发送方到接收方期间，信道上可以容纳1/25% = 4个帧；<br>
延迟为50ms，也就是发送一个900bit的帧，需要50ms到达接收方；<br>
带宽延迟乘积BD = 带宽 * 0.05s = 4 * 900bit，所以带宽为72kb/s。

31. 在一个带宽为50kb/s的信道上使用300比特的帧，一个停-等式协议达到了60%的带宽效率。该信道的单向传输延迟是多少？<br>
**解答**：设单向传输延迟为t，则50000b/s * t = 300bit/60%，解得t = 0.01s = 10ms。<br>
所以，该信道的单向传输延迟是10ms。

32. 在一个单向传输延迟为8ms并且带宽为1200kb/s的信道上使用800比特的帧，采用停-等式协议。该协议在这一信道上能达到的带宽效率是多少？<br>
**解答**：带宽延迟乘积为：1200kb/s * 0.008s = 9.6kb；<br>
带宽效率为：800bit/9.6kbit = 1/12。

33. 一个滑动窗口协议使用1000比特的帧，其发送窗口的大小固定为3。在一个250kb/s的信道上它达到了几乎100%的带宽效率。同样的协议也被用在一个升级后的信道上，该信道有同样的延迟，但带宽是原来的2倍。该协议在新的信道上的带宽效率是多少？<br>
**解答**：发送窗口大小为3，也就是一次往链路上发送3个1000bit的帧，且达到了几乎100%的带宽效率，说明链路上最多存在的比特数为：3 * 1000 = 3000bit = 3kb；<br>
则该信道的单向传输延迟为：3/250s；<br>
新的信道的带宽为：250 * 2 = 500kb/s；<br>
该协议在新的信道上的带宽效率为：3kb/(500kb/s * 3/250s) = 50%。

34. 在协议3中，当发送方的计时器已经开始运行时，它还有可能启动该计时器吗？如果可能，这种情况是如何发生的？如果不可能，为什么？<br>
**解答**：有可能。协议3是ARQ协议（自动重传请求协议）。假定帧的发送和ACK的应答非常迅速，发送方发送了一个帧，但应答帧ACK在途中被破坏，发送方收到时识别不了。在这种情况下，发送方第二次发送该帧，并启动计时器，此时上一次启动的计时器仍在运行。

35. 使用协议5在一条3000km长的T1中继线上传输64字节的帧。如果信号的传播速度为6μs/km，序号应该有多少位？<br>
**解答**：序列空间必须足够大，使得在第一个ACK应答返回之前，其他数据能持续传输；<br>
一个帧在中继线上传输的时间为：3000km×6μs/km=18ms；<br>
T1数据速率是125微秒传送一个193bit的帧，则传输一个64字节的帧需要：193/125 * 64 * 8 = 0.3ms；<br>
所以第一帧从发送端到达接收端的时间是18 + 0.3 = 18.3ms，ACK回复需要18ms（ACK长度忽略不计），所以第一帧从发送到接收到ACK应答需要36.3ms；<br>
发送的序号必须大到36.3ms内不间断传输，每个帧发送时间是0.3ms，36.3/0.3 = 121，即在从第一帧发送至收到第一个ACK期间有121个帧被发出，所以需要7位序号位。

36. 想象一个滑动窗口协议，它的序号占用的位数相当多，使得序号几乎永远不会回转。4个窗口边界和窗口大小之间必须满足什么样的关系？假设这里发送方和接收方的窗口大小固定不变并且相同。<br>
**分析**：窗口边界之间的空间必须小于窗口大小；<br>
接收窗口的第一个边界应该嵌合在发送方窗口的两个边界之中，以方便返回nak；<br>
问题的关键在于，接收方向前移动其窗口，新的有效的序列号范围不与原先的有效序列号范围重叠；为保证不发生重叠，最大窗口尺寸应该不超过序列号范围的一半；如果用4位来表示序列号，其范围是0～15；任何时刻，只允许有8个未确认帧；这样一来，如果接收过程刚刚接收了0～7号帧，向前移动了窗口，允许进行第8～15号帧的接收，那么就能分辨出后继帧是重发帧（由于传输过程中确认帧丢失，或发送方超时重传）0～7还是新帧8～15。<br>
**解答**：设发送方的窗口边界是(S_l,S_r)，接收方的窗口边界是(R_l,R_r)，窗口大小为W，则它们之间的关系为：<br>
$0<=S_r-S_l+1<=W$<br>
$R_r- R_l+1=W$<br>
$S_l<=R_l<=S_r+1$

37. 在协议6中，当一个数据帧到达时，需要检查它的序号是否不同于期望的序号，并且no_nak为真。如果这两个条件都成立，则发送一个NAK；否则，启动辅助计时器。假定else子句被省略，这种改变会影响协议的正确性吗？<br>
**分析**：no_nak为真，表示还没有发送过NAK；<br>
else子句即为“否则，启动辅助计时器”。<br>
**解答**：会影响协议的正确性，可能造成死锁。假设一批帧已到达并且被接收，接收方会推进其窗口；若所有ACK丢失，发送定时器会出现超时，然后重新发送第一个帧，接收方会发送NAK，然后no_nak被设置成伪；如果NAK也丢失，那么发送方会保持超时，并不断发送已经被接收方接收了的帧，而接收方只是忽略这些帧，由于no_nak为伪，所以接收方不会再发送NAK，那么发送者就会不断发送，最后造成死锁；如果设置辅助计数器（实现else语句），超时后重发NAK帧，终究会使双方获得同步。

38. 假设将协议6中靠近尾部的内含3条语句的while循环去掉，这样会影响协议的正确性还是只是仅仅影响协议的性能？请解释你的答案。<br>
**分析**：3条语句为：<br>
while{between(ack_expected, r.ack, next_frame_to_send))<br>
	(nbuffered=nbuffered-1;	/*处理捎带确认*/<br>
stop_timer(ack_expected%NR_BUFS);		/*帧完整到达*/<br>
inc(ack_expected)	/*将发送方窗口的低端向前推进*/<br>
}<br>
这里的nbuffered表示发送缓存中保留的输出帧的数目，ack_expected表示下一个期待接收的确认帧的号码。<br>
**解答**：这会影响协议的正确性，造成死锁；这里是唯一用来处理ACK的进程，如果没有这段代码，发送者会保持超时状态，不再做任何事。

39. 在第38题中，假设使用滑动窗口协议。多大的发送窗口才能使得链路利用率为100%？发送方和接收方的协议处理时间可以忽略不计。<br>
**解答**：38题没有那段代码会导致发送方发送完发送窗口内的数据就不再做任何事，要想避免这种情况发生，链路利用率达到100%，发送窗口的大小必须和需要发送的所有数据需要的帧数目大小相同。

40. 假设在协议6的switch语句中，将校验和错误的case分支去掉。这一改变将如何影响协议的运行？<br>
**解答**：将会取消否定确认的功能，因此将回到超时重传操作；虽然性能有所减退，但不会影响数据传输服务的正确性；NAK不是必须的。

41. 在协议6中，frame_arrival代码中有一部分是用来处理NAK的。如果进来的帧是一个NAK，并且另一个条件也满足，则这部分代码会被调用。请给出一个场景，在此场景下另一个条件非常关键。<br>
**分析**：代码中的语句如下：<br>
if((r.kind == nak) && between(ack_expected, (r.ack+1)%(MAX_SEQ+1), next_frame_to_send))<br>
	send_frame(data, (r.ack+1)%(MAX_SEQ+1), frame_expected, out_buf);<br>
**解答**：这里要求r.ack+1<next_frame_to_send。考虑以下场景：<br>
A站发送0号帧给B站，B站收到这个帧，并返回ACK帧，但是ACK被传丢了；A站发生超时，重传0号帧，但是B站在期待接收1号帧，因此B发送NAK，否定收到的0号帧；显然，现在A站最好不重发0号帧。对于A站接收到NAK，由于条件r.ack+1<next_frame_to_send不成立，所以用不着选择性重传0号帧，可以继续向前推进传送1号帧。这个例子就说明了这段程序中的另一个条件r.ack+1<next_frame_to_send也是重要的。

42. 考虑在一条不会出错的1Mb/s线路上使用协议6.帧的最大长度为1000位。每过1s产生一个新数据包。超时间隔为10ms。如果取消特殊的确认计时器，那么就会发生不必要的超时事件。消息平均要被传输多少次？<br>
**分析**：特殊的确认计时器：即为ACK超时机制<br>
**解答**：发送1位数据用时1/1000000=1微秒，发送1000bit的最长帧花费1ms；<br>
超时间隔是10ms，1s才能产生出一个新的数据帧，所以超时是不可避免的；<br>
假定A站向B站发送一个帧，正确到达，但是较长时间无反向ACK；不久，A站发生超时事件，导致重发已经发送过的一帧；B站发现收到的帧序列号错误，因为该序列号小于所期待接收的序列号，B站将发送一个NAK，该NAK会携带一个确认号，导致不再重发该帧；结果是，每个帧都被发送两次。

43. 在协议6中，MAX_SEQ=2^n-1。这一条件显然是希望有效地利用头部空间，但并不是说这个条件是必不可少的。比如，当MAX_SEQ=4时协议也能够正确工作吗？<br>
**解答**：不能，协议的运行将会失败。当MAX_SEQ = 4时，序列号的模数n = 4+1 = 5（即序列号可以是0，1，2，3，4）,窗口大小等于：NrBufs≤5/2=2.5，所以NrBufs=2，即为2个窗口；<br>
因此，在该协议中，偶数序号使用缓冲区0，奇数序号使用缓冲区1，这种映射意味着帧4和0将使用同一缓冲区；<br>
假定0至3号帧都正确收到了，并且都确认应答了，如果随后的4号帧丢失，且下一个0号帧收到了，新的0号帧将被放到缓冲区0中，变量arrived[0]被置成“真”，这样，一个失序帧将被投递给主机；<br>
事实上，采用选择性重传的滑动窗口协议需要MAX_SEQ是奇数才能正确的工作；<br>
然而其他滑动窗口协议的实现并不具有这一性质。

44. 利用地球同步卫星在一个1Mb/s的信道上发送长度为1000位的帧，该信道与地球之间的传播延迟为270ms。确认总是被捎带在数据帧中。帧头非常短，序号使用了3位。在下面的协议中，可获得的最大信道利用率是多少？<br>
（a）停-等式。<br>
（b）协议5。（回退N滑动窗口协议）<br>
（c）协议6。（选择性重传滑动窗口协议）<br>
**解答**：对应三种协议的窗口大小值分别是1、7和4。<br>
卫星信道端到端的传输延迟是270ms，以1Mbps发送，1000bit长的帧发送时间是1ms；用t=0表示传输开始时间，则t=1ms时，第一帧发送完毕；t=271ms时，第一帧完全到达接收方；t=272ms时，对第一个帧的确认帧从接收方发送完毕；t=542ms时，带有确认的帧完全到达发送方；因此周期是542ms。<br>
如果在542ms内能发送k个帧（每个帧发送用1ms时间），则信道利用率是k/542，所以：<br>
	k=1，最大信道利用率=1/542≈0.18%<br>
	k=7，最大信道利用率=7/542≈1.29%<br>
	k=4，最大信道利用率=4/542≈0.74%

45. 否定确认直接触发发送方的应答，而缺少肯定确认只是触发了超时之后的一个动作。是否有可能只使用否定确认，而不使用肯定确认来建立一个可靠的通信信道？如果有可能，请给出一个例子；如果不可能，请解释为什么。<br>
**解答**：可能。当只有NAK而没有ACK时，发送方发送一个帧，接收方收到，并不会给发送方返回ACK，只是等待接收后面的帧，而发送方并不知道接收方有没有收到这个帧，只是一直等待，直到计时器超时，然后再重发一遍这个帧给接收方，这时接收方发现这个帧是重复帧，会返回一个NAK给发送方，并写出想要的是下一帧，这时发送方会立刻发送下一帧给接收方。这样每个帧都至少被发送两遍。

46. 考虑在一个无错的64Kb/s卫星信道上单向发送512字节长的数据帧，来自另一个方向反馈的确认非常短。对于窗口大小为1、7、15和127的情形，最大的吞吐量分别是多少？从地球到卫星的传播时间为270ms。<br>
**分析**：卫星信道端到端延迟是270ms；512Byte = 512 * 8bit = 4096bit；；64kb/s = 64000b/s= 64b/ms。<br>
**解答**：512字节长的数据占用通道的时间是：4096bit/(64000b/s) = 0.064s = 64ms。<br>
用t = 0表示传输开始时间，t = 64ms时，第一帧发送完毕，t = 64 + 270 = 334ms时，第一帧完全到达接收方，并开始返回很短的确认帧（发送时间忽略不计），确认帧到达发送方的时间是t = 334 + 270 = 604ms；因此，周期等于604ms，需要窗口大小为604ms/(64b/ms)≈9个帧才能保持通道不空。<br>
对于窗口值1，每604ms可发送4096bit，吞吐率为：4096/0.604 ≈ 6781b/s;<br>
对于窗口值7，吞吐率为：6781 * 7 = 47467b/s，约为47.5Kb/s；<br>
对于窗口值超过9帧（包括15帧和127帧的情况），吞吐率达到完全速率64Kb/s。

47. 在一条100km长的线缆上运行T1数据速率。线缆中的传播速度是真空中光速的2/3。线缆中可以容纳多少位？<br>
**解答**：电缆中的传播速度是3×10^8×2/3=2×10^8 m/s，即200000km/s，也就是200km/ms，因此，100km的线缆将会在0.5ms时间内填满。<br>
T1数据速率是125微秒传送一个193bit的帧，0.5ms（即500微秒）可传送4个T1的帧：193bit * 4 = 772bit。<br>
所以线缆中可以容纳772位。

48. PPP使用字节填充而不是比特填充，这样做的目的是防止有效载荷字段偶尔出现的标志字节造成的混乱。请至少给出一个理由说明PPP为什么这么做。<br>
**解答**：PPP被明确地设计成是以软件形式实现的，对于软件实现，完全用字节操作要比用单个位操作简单得多。此外，PPP被设计成跟调制解调器一道使用，而调制解调器是以1个字节为单元而不是以1个比特为单元接受和发送数据的。

49. 使用PPP发送一个IP数据包的最小开销是多少？如果只计由PPP自身引入的开销，而不计IP头开销，最大开销又是多少？<br>
![image.png](https://github.com/datawhalechina/hello-net/blob/main/pics/3_49.png)<br>
**解答**：PPP的帧格式如图。<br>
由于在默认配置下，地址和控制字段总是常数，因此链路控制协议(LCP)为这2部分提供了必要的机制，可以协商选项，允许省略掉这2个字段，从而在每帧上节省2个字节；<br>
协议段默认大小为2字节，但在使用LCP时，可以变成一个字节；<br>
在最小开销条件下，每个帧有2个标志字节，1个协议字节和2个检验和字节，这样，每个帧一共有5个字节。<br>
最大开销：2个标志字节，1个地址字节，1个控制字节，2个协议字节，4个检验字节，一共是10个字节。

50. 下面的数据流是在SONET上使用PPP帧发送的：ESC FLAG FLAG ESC。在有效载荷中传输的字节序列是什么？将你的答案写成一个字节序列，每一字节用8个1或0表示。代表ESC的比特序列是01111101，代表FLAG的比特序列是01111110。<br>
**解答**：有效载荷中传输的序列是：ESC ESC ESC FLAG ESC FLAG ESC ESC；<br>
写成字节序列是：01111101 01111101 01111101 01111110 01111101 01111110 01111101 01111101。

51. 在本地回路上使用ADSL协议栈发送一个长为100字节的IP数据包。一共要发送多少个ATM信元？请简要描述这些信元的内容。<br>
**解答**： 发送100字节的IP数据包的AAL5帧含有2 个PPP 协议字节，100个有效负载字节，0～47个填充字节和8个帧尾；<br>
要使这个帧长度为48的整数，填充字节需要34个，这使得最终AAL5帧长为144bytes，是48的3倍；<br>
可以发送3个ATM信元：第一个信元包含2个PPP 协议字节，46字节的IP包；第二个信元包含后继的48字节IP 包；第三个信元包含最后6个字节IP包，34个填充字节和8个帧尾。

52. 本题的目标是用本章描述的标准CRC算法实现一个错误检测机制。编写两个程序：generator和verifier。generator程序从标准输入读取一行ASCII文本，该文本包含由0和1组成的n位消息。第二行是一个k位多项式，也是以ASCII码表示的。程序输出到标准输出设备上的是一行ASCII码，由n+k个0和1组成，表示被发送的消息。然后，它输出多项式，就像它输入的那样。verifier程序读取generator程序的输出，并输出一条消息指示正确与否。最后，再写一个程序alter，它根据参数（从最左边开始1的比特数）反转第一行中的比特1，但正确复制两行中的其余部分。通过输入<br>
generator < file | verifier<br>
应该能看到提示正确的消息，但输入<br>
generator < file | alter arg | verifier<br>
应该得到提示错误的消息。<br>
**分析**：本题是首先发送方通过 CRC 算法将数据帧（0 和 1 的字符串）根据生成多项式算出其校验和，然后附加到数据帧的尾部，作为输出，此部分通过generator 程序实现；然后接收方读取带校验和的数据帧，用生成多项式去除它，通过余数是否为 0 判定传输是否出错，此部分通过 verifier 程序实现；最后通过改变数据帧中的某位，用 verifier 再去验证，得出数据帧有误的结论，此部分通过 alter 程序实现。<br>
有兴趣的同学可以自己尝试实现。<br>



参考：
【1】[Hamming code-汉明码(中文)](https://www.cnblogs.com/LinQingYang/p/11985595.html)<br>
【2】[计算机网络 习题与解析（第2版）](https://books.google.co.jp/books?id=GiOFvcMMQR0C&pg=PT1&dq=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C+%E9%B2%81%E5%A3%AB%E6%96%87&hl=zh-CN&sa=X&ved=2ahUKEwi3tpTn8vX6AhXhslYBHQbHCDMQ6AF6BAgPEAI#v=onepage&q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E9%B2%81%E5%A3%AB%E6%96%87&f=false)<br>
【3】[网际校验和算法（Internet CheckSum）](https://blog.51cto.com/u_15080021/4733444)<br>
【4】[【计算机网络】第三章数据链路层习题及参考答案](https://blog.csdn.net/daemon_slp/article/details/109993174)<br>
【5】《计算机网络(第6版)》，Andrew S.Tanenbaum, Nick Feamster, David J.Wetherall著，潘爱民译
